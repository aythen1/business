
import React, { useEffect, useState, useRef } from "react";

import { useDispatch, useSelector } from 'react-redux'

import ReactDOM from 'react-dom';
import html2canvas from 'html2canvas';
import domtoimage from 'dom-to-image';


import Editor from "@monaco-editor/react";
import { useEditor } from "@tldraw/tldraw";
import { Tldraw } from "@tldraw/tldraw";
import { getSvgAsImage } from "@/lib/getSvgAsImage";
import { blobToBase64 } from "@/lib/blobToBase64";


import {
  setOpenMenuRight,
  setOpenChatBot
} from '@/actions/iam'


import {
  addMessage
} from '@/actions/chatbot'



import IconCopy from './assets/copy.png'
import IconDelete from './assets/delete.png'
import IconMove from './assets/move.png'
import IconCode from './assets/code.png'
import IconView from './assets/view.png'
import IconGPT from './assets/gpt.png'


// import DOMPurify from 'dompurify';


// import "@tldraw/tldraw/tldraw.css";
// import { htmlExample1 } from './html/example-1'







function obtainContent(texto, type = 'html') {
  const regexString = '```' + type + '\\s*([\\s\\S]*?)```';
  const regex = new RegExp(regexString);
  const coincidencia = texto.match(regex);

  if (coincidencia && coincidencia[1]) {
    return coincidencia[1].trim();
  } else {
    return null;
  }
}


const Addon = ({
  component
}) => {
  const dispatch = useDispatch()

  const [html, setHtml] = useState(component.code);

  const [activeTab, setActiveTab] = useState("preview");



  const handleEditorChange = (value, event) => {
    // Este handler se activará cuando cambie el contenido del editor
    setHtml(value);
  };

  useEffect(() => {
    // Puedes agregar aquí cualquier lógica adicional que necesites al actualizar el HTML
  }, [html, activeTab]);



  if (!html) {
    return null;
  }

  // handle -------------------------------------------------------

  const handleComponentCop = () => {
    if (hoveredElement) {
      const el = hoveredElement;

      const customButtonsElement = el.querySelector('.customButtons');
      if (customButtonsElement) {
        customButtonsElement.remove();
      }

      const outerHtml = el.outerHTML;

      // Crear un elemento de texto temporal para copiar al portapapeles
      const tempElement = document.createElement('textarea');
      tempElement.value = outerHtml;
      document.body.appendChild(tempElement);

      // Seleccionar y copiar al portapapeles
      tempElement.select();
      document.execCommand('copy');

      // Eliminar el elemento temporal
      document.body.removeChild(tempElement);
    }
  }

  const handleComponentDelete = () => {
    if (hoveredElement) {
      hoveredElement.remove();
    }
  }

  const handleComponentGPT = async (e) => {
    e.preventDefault()

    if (hoveredElement) {
      // Oculta temporalmente el elemento capturado
      // hoveredElement.style.visibility = 'hidden';

      // Captura solo el elemento y sus descendientes
      // const canvas = await html2canvas(hoveredElement);

      // const customButtonsElement = hoveredElement.querySelector('.customButtons');
      // if (customButtonsElement) {
      //   customButtonsElement.remove();
      // }


      const dataUrl = await domtoimage.toPng(hoveredElement);
      // Restaura la visibilidad del elemento
      // hoveredElement.style.visibility = 'visible';

      // Espera a que html2canvas complete su trabajo
      await new Promise(resolve => setTimeout(resolve, 2000)); // Ajusta el tiempo según sea necesario


      console.log('dataUrl', dataUrl)

      // Convertir el canvas a una imagen
      // const image = canvas.toDataURL('image/png');

      // Crear un enlace para descargar la imagen
      // const downloadLink = document.createElement('a');
      // downloadLink.href = image;
      // downloadLink.download = 'captura.png'; // Puedes cambiar el nombre del archivo según tus necesidades

      // Almacena la imagen base64 en el estado
      dispatch(addMessage({
        vector: '12345',
        date: new Date(),
        buffer: dataUrl
      }));
    }

    dispatch(setOpenChatBot(true))
  }

  const handleComponentMove = () => {
    alert(1)
  }

  const handleComponentCode = () => {

  }


  // html -----------------------------------------------------------
  const [isMove, setIsMove] = useState(false)
  const [isHovered, setIsHovered] = useState(false);
  const [hoveredElement, setHoveredElement] = useState(null);
  // const [hoveredSelector, setHoveredSelector] = useState('');
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const containerRef = useRef(null);

  const handleMouseOver = (event) => {
    if (isAltKeyPressed()) {
      // Obtener el selector del elemento actual
      const newHoveredElement = document.elementFromPoint(event.clientX, event.clientY);

      console.log('handleMouseOver', newHoveredElement, !isLeavingToButtons(event.relatedTarget))
      if (newHoveredElement && !isLeavingToButtons(event.relatedTarget)) {
        document.querySelectorAll('.customButtons').forEach((buttonsDiv) => { buttonsDiv.remove() });
        document.querySelectorAll('.selectedComponent').forEach(element => element.classList.remove('selectedComponent'));

        newHoveredElement.classList.add('selectedComponent')
        setPosition({ x: event.clientX, y: event.clientY });
        setHoveredElement(newHoveredElement);
        addButtonsToElement(newHoveredElement);
      }
    }
  };

  const handleMouseOut = (event) => {
    console.log('handleMouseOut', event.relatedTarget?.closest('.selectedComponent'))
    if (!isMove && hoveredElement && !event.relatedTarget?.closest('.selectedComponent') && !isLeavingToButtons(event.relatedTarget)) {
      document.querySelectorAll('.customButtons').forEach((buttonsDiv) => { buttonsDiv.remove() });
      document.querySelectorAll('.selectedComponent').forEach(element => element.classList.remove('selectedComponent'));

      setHoveredElement(null);
    }
  };



  const isLeavingToButtons = (relatedTarget) => (
    relatedTarget && (
      relatedTarget.classList.contains('customButtons') ||
      relatedTarget.closest('.customButtons')
    )
  );



  const isAltKeyPressed = () => {
    return window.event ? window.event.altKey : false;
  };

  const getSelector = (element) => {
    const selectors = [];
    let targetElement = element;

    const collectSelectors = (el) => {
      const id = el.id;
      if (id) {
        selectors.push(`#${id}`);
      }

      const classNames = Array.from(el.classList).join('.');
      if (classNames) {
        selectors.push(`.${classNames}`);
      }
    };

    collectSelectors(element);

    const selector = selectors.join(' ');

    return selector;
  };

  const addButtonsToElement = (element) => {
    const CustomButtons = () => {
      return (
        <div className="notHover">
          <div className="notHover">
            <button className="notHover" onClick={(e) => handleComponentGPT(e)}>
              <img src={IconGPT} />
            </button>
            <button className="notHover" onClick={(e) => handleComponentCode(e)}>
              <img src={IconCode} />
            </button>
          </div>
          <div className="notHover">
            <button className="notHover" onClick={(e) => handleComponentCop(e)}>
              <img src={IconCopy} />
            </button>
            <button className="notHover" onClick={(e) => handleComponentDelete(e)}>
              <img src={IconDelete} />
            </button>
          </div>
        </div>
      );
    };

    const buttonsDiv = document.createElement('div');
    buttonsDiv.className = 'customButtons';
    ReactDOM.render(<CustomButtons />, buttonsDiv);
    element.appendChild(buttonsDiv);
  };





  // --------------------------------------
  const handleKeyDown = (e) => {
    e.preventDefault();

    const currentElement = document.querySelector('.selectedComponent');
    console.log('selectedComponent', currentElement);

    if (currentElement) {
      const parentElement = currentElement.parentElement;
      const nextElement = currentElement.nextElementSibling;
      const prevElement = currentElement.previousElementSibling;

      console.log('prevElement', prevElement);

      if (e.key === 'ArrowUp' && parentElement && parentElement !== document.body) {
        setIsMove(true)
        // Mover hacia arriba en la jerarquía del DOM
        if (prevElement) {
          if (prevElement.lastElementChild) {
            // Si el elemento anterior tiene hijos, haz que el actual sea el último hijo
            prevElement.lastElementChild.appendChild(currentElement);
          } else {
            parentElement.insertBefore(currentElement, prevElement);
          }
        } else {
          console.log('11111');
          const grandparentElement = parentElement.parentElement;
          grandparentElement.insertBefore(currentElement, parentElement);
        }
      } else if (e.key === 'ArrowDown' && nextElement) {
        setIsMove(true)
     
      // Mover hacia abajo en la jerarquía del DOM
      if (!nextElement) {
        // Si no hay siguiente, colocamos el elemento después del padre
        parentElement.parentElement.insertBefore(currentElement, parentElement.nextElementSibling);
      } else {
        // Si hay un siguiente elemento
        if (nextElement.children.length > 0) {
          // Si el siguiente tiene hijos, el current pasa a ser el primer hijo de ese elemento
          nextElement.insertBefore(currentElement, nextElement.firstElementChild);
        } else {
          // Si el siguiente no tiene hijos
          parentElement.removeChild(currentElement);
          nextElement.appendChild(currentElement);

          // Si es el último, realiza el paso 1 (colocar después del padre)
          if (!nextElement.nextElementSibling) {
            parentElement.parentElement.insertBefore(currentElement, parentElement.nextElementSibling);
          }
        }
      }
      }
    }
  };




  const swapElements = (el1, el2) => {
    const parent = el1.parentNode;
    const nextSibling = el1.nextSibling === el2 ? el1 : el2.nextSibling;

    el2.parentNode.insertBefore(el1, el2);
    parent.insertBefore(el2, nextSibling);
  };

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, []);





  return (
    <div
      onClick={(e) => {
        e.stopPropagation();
      }}
      className=""
    >
      <div
        ref={containerRef}
        style={{ background: '#fff' }}
        className={`hoverable ${isHovered ? 'hovered' : ''}`}
        onMouseOver={handleMouseOver}
        onMouseOut={handleMouseOut}
        dangerouslySetInnerHTML={{ __html: html }}
      >
        {/* {isHovered && <div>Hovered Selector: {hoveredSelector}</div>} */}
      </div>
    </div>
  );
};


export default Addon;





const ComponentCustom = ({ }) => {
  return (
    <div>
      {activeTab === "preview" ? (
        <div>

        </div>
      ) : activeTab === "editor" ? (
        <div style={{ width: '100%', height: '100vh' }}>
          <Tldraw
            persistenceKey="tldraw">
            <ExportButton setHtml={setHtml} />
          </Tldraw>
        </div>
      ) : (
        <Editor
          height="100vh"
          language="html"
          theme="vs-dark"
          value={html}
          onChange={handleEditorChange}
          options={{
            readOnly: false,
            minimap: { enabled: false },
          }}
        />
      )}
    </div>
  )
}












const ExportButton = ({ setHtml }) => {
  // const editor = useEditor();
  const [loading, setLoading] = useState(false);
  // A tailwind styled button that is pinned to the bottom right of the screen
  return (
    <button
      onClick={async (e) => {
        setLoading(true);
        try {
          e.preventDefault();
          const svg = []
          // const svg = await editor.getSvg(
          //   Array.from(editor.currentPageShapeIds)
          // );
          if (!svg) {
            return;
          }
          const png = await getSvgAsImage(svg, {
            type: "png",
            quality: 1,
            scale: 1,
          });
          const dataUrl = await blobToBase64(png);
          const resp = await fetch("https://business.ay-cloud.com/service/v1/openai/test", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ image: dataUrl }),
          })


          const json = await resp.json();

          // console.log('json', json.choices[0].message.content)

          if (json.error) {
            // console.log("Error from open ai: " + JSON.stringify(json.error));
            return;
          }


          var html = obtainContent(json[0])
          console.log('html: ', html)
          // console.log('result', data)

          // const message = json.choices[0].message.content;
          // const start = message.indexOf("<!DOCTYPE html>");
          // const end = message.indexOf("</html>");
          // const html = message.slice(start, end + "</html>".length);
          setHtml(html);
        } finally {
          setLoading(false);
        }
      }}
      className="fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded ="
      style={{ zIndex: 1000, position: 'relative' }}
    >
      {loading ? (
        <div className="flex justify-center items-center ">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
        </div>
      ) : (
        "Make Real"
      )}
    </button>
  );
}









// const ExportButton = ({ setHtml }) => {
//   // const editor = useEditor();
//   const [loading, setLoading] = useState(false);
//   // A tailwind styled button that is pinned to the bottom right of the screen
//   return (
//     <button
//       onClick={async (e) => {
//         setLoading(true);
//         try {
//           e.preventDefault();
//           const svg = []
//           // const svg = await editor.getSvg(
//           //   Array.from(editor.currentPageShapeIds)
//           // );
//           if (!svg) {
//             return;
//           }
//           const png = await getSvgAsImage(svg, {
//             type: "png",
//             quality: 1,
//             scale: 1,
//           });
//           const dataUrl = await blobToBase64(png);
//           const resp = await fetch("https://business.ay-cloud.com/service/v1/openai/test", {
//             method: "POST",
//             headers: {
//               "Content-Type": "application/json",
//             },
//             body: JSON.stringify({ image: dataUrl }),
//           })

//           // console.log('resp', resp)

//           const json = await resp.json();

//           // console.log('json', json.choices[0].message.content)

//           if (json.error) {
//             // console.log("Error from open ai: " + JSON.stringify(json.error));
//             return;
//           }


//           var html = obtainContent(json[0])
//           console.log('html: ', html)
//           // console.log('result', data)

//           // const message = json.choices[0].message.content;
//           // const start = message.indexOf("<!DOCTYPE html>");
//           // const end = message.indexOf("</html>");
//           // const html = message.slice(start, end + "</html>".length);
//           setHtml(html);
//         } finally {
//           setLoading(false);
//         }
//       }}
//       className="fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded ="
//       style={{ zIndex: 1000, position: 'relative' }}
//     >
//       {loading ? (
//         <div className="flex justify-center items-center ">
//           <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
//         </div>
//       ) : (
//         "Make Real"
//       )}
//     </button>
//   );
// }